# -*- coding: utf-8 -*-
"""twitter Spam ML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FrI940sUNwMWUj-gVz5S40GuKNZBwwd1

# Prediction using the tweet (text)

Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style("darkgrid")
# %matplotlib inline

import string
import nltk
from nltk.corpus import stopwords

from wordcloud import WordCloud
from sklearn.feature_extraction.text import CountVectorizer
from nltk.stem import WordNetLemmatizer

from sklearn.model_selection import train_test_split
from sklearn import metrics

import matplotlib.pyplot as plt
import seaborn as sns
import plotly
import plotly.graph_objects as go
import cufflinks as cf
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot
init_notebook_mode(connected=True)
cf.go_offline()

df = pd.read_csv('train1.csv')
df.head()

df.info()

df.describe()

df.groupby('Type').describe().T

df = df[df.Type != "South Dakota"]

df.groupby('Type').describe().T

df['length'] = df['Tweet'].apply(len)
df.head()

# convert categorical v1 to numerical with new column
df['v1_nm'] = df.Type.map({'Quality':0, 'Spam':1})
df.head()

df['Type'].value_counts()

# interactive plotly hist plot for numerical vi_nm columns(i,e ham and spam)
df['v1_nm'].iplot(kind='hist')

plt.figure(figsize=(12,8))
df[df['Type']=='Quality'].length.plot(bins = 50, kind= 'hist', color='blue', label='ham', alpha=0.75)
df[df['Type']=='Spam'].length.plot(bins=50, kind= 'hist', color='red', label = 'spam', alpha=0.75)
plt.legend()
plt.xlabel('Message length')

# describe the ham for some numerical insights
df[df['Type']=='Quality'].describe()

#describe the both numerical columns
df.describe()

# see in describe we have 684 word message, let's look at it
df[df['length']==684].Tweet.iloc[0]

"""Pre processing"""

import string
from nltk.corpus import stopwords

def text_process(mess):
    """
    Takes in a string of text, then performs the following:
    1. Remove all punctuation
    2. Remove all stopwords
    3. Returns a list of the cleaned text
    """
    STOPWORDS = stopwords.words('english') + ['u', 'Ã¼', 'ur', '4', '2', 'im', 'dont', 'doin', 'ure']

    # Check characters to see if they are in punctuation
    nopunc = [char for char in mess if char not in string.punctuation]

    # Join the characters again to form the string.
    nopunc = ''.join(nopunc)

    # Now just remove any stopwords
    return ' '.join([word for word in nopunc.split() if word.lower() not in STOPWORDS])

import nltk
nltk.download('stopwords')

df['clean_msg'] = df.Tweet.apply(text_process)

df.head()

from collections import Counter

words = df[df['Type']=='Quality'].clean_msg.apply(lambda x: [word.lower() for word in x.split()])
ham_words = Counter()

for msg in words:
    ham_words.update(msg)

print(ham_words.most_common(50))

words = df[df.Type=='Spam'].clean_msg.apply(lambda x: [word.lower() for word in x.split()])
spam_words = Counter()

for msg in words:
    spam_words.update(msg)

print(spam_words.most_common(50))

"""Vectorization"""

X = df.clean_msg
y = df.v1_nm
print(X.shape)
print(y.shape)

# split X and y into training and testing sets
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)
print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

from sklearn.feature_extraction.text import CountVectorizer

# instantiate the vectorizer
vect = CountVectorizer()
vect.fit(X_train)

# learn training data vocabulary, then use it to create a document-term matrix
X_train_dtm = vect.transform(X_train)

# equivalently: combine fit and transform into a single step
X_train_dtm = vect.fit_transform(X_train)

# examine the document-term matrix
X_train_dtm

# transform testing data (using fitted vocabulary) into a document-term matrix
X_test_dtm = vect.transform(X_test)
X_test_dtm

from sklearn.feature_extraction.text import TfidfTransformer

tfidf_transformer = TfidfTransformer()
tfidf_transformer.fit(X_train_dtm)
tfidf_transformer.transform(X_train_dtm)

"""Test based Multinomial Naive Bayers"""

from sklearn.naive_bayes import MultinomialNB
nb = MultinomialNB()

# Commented out IPython magic to ensure Python compatibility.
# train the model using X_train_dtm (timing it with an IPython "magic command")
# %time nb.fit(X_train_dtm, y_train)

# make class predictions for X_test_dtm
y_pred_class = nb.predict(X_test_dtm)
y_pred_class

# calculate accuracy of class predictions
from sklearn import metrics
metrics.accuracy_score(y_test, y_pred_class)

# print the confusion matrix
metrics.confusion_matrix(y_test, y_pred_class)
print(metrics.classification_report(y_test, y_pred_class))

"""Real tweets with world health day"""

df2=pd.read_csv('WorldHealthDay.csv')
df2.head()

realtest = vect.transform(df2['tweets'])
y_pred_class = nb.predict(realtest)
y_pred_class

df3=pd.read_csv('test.csv')
df3.head()

comp = vect.transform(df3['Tweet'])
y_pred_class = nb.predict(comp)
y_pred_class

ans = pd.DataFrame()
ans["Id"] = np.arange(0,785)
ans["Type"] = y_pred_class
print(ans.head())

from pathlib import Path
filepath = Path('submission.csv')
ans.to_csv(filepath)
# # print(data_test)

"""Logistic Regression"""

from sklearn.linear_model import LogisticRegression
logreg = LogisticRegression(solver='liblinear')

# Commented out IPython magic to ensure Python compatibility.
# train the model using X_train_dtm
# %time logreg.fit(X_train_dtm, y_train)

# make class predictions for X_test_dtm
y_pred_class = logreg.predict(X_test_dtm)
y_pred_class

# calculate accuracy
metrics.accuracy_score(y_test, y_pred_class)

print(metrics.classification_report(y_test, y_pred_class))

# # calculate predicted probabilities for X_test_dtm (well calibrated)
y_pred_prob = logreg.predict_proba(X_test_dtm)[:, 1]
y_pred_prob

comp = vect.transform(df3['Tweet'])
y_pred_class = logreg.predict_proba(comp)
y_pred_class

# calculate AUC
metrics.roc_auc_score(y_test, y_pred_prob)

"""RandomForest"""

from sklearn.ensemble import RandomForestClassifier

spam_classifier = RandomForestClassifier(n_estimators=200, random_state=0)
spam_classifier.fit(X_train_dtm, y_train)
# Use the classifier for predictions
predictions = spam_classifier.predict(X_test_dtm)

print(metrics.confusion_matrix(y_test, predictions))
print(metrics.accuracy_score(y_test, predictions))
print(metrics.classification_report(y_test, predictions))

"""Support vector machines"""

#Import svm model
from sklearn import svm

#Create a svm Classifier
clf = svm.SVC(kernel='linear') # Linear Kernel

#Train the model using the training sets
clf.fit(X_train_dtm, y_train)

#Predict the response for test dataset
y_pred = clf.predict(X_test_dtm)

print(metrics.accuracy_score(y_test, y_pred))
print(metrics.classification_report(y_test, y_pred))

"""Decision Tree"""

from sklearn.tree import DecisionTreeClassifier
spam_classifier = DecisionTreeClassifier()
spam_classifier.fit(X_train_dtm, y_train)
# Use the classifier for predictions
predictions = spam_classifier.predict(X_test_dtm)

print(metrics.confusion_matrix(y_test, predictions))
print(metrics.accuracy_score(y_test, predictions))
print(metrics.classification_report(y_test, predictions))

"""# Statistical based spam prediction using features

KNN
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import numpy as np
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import scipy.stats as stats
matplotlib.style.use('ggplot')
from sklearn import linear_model
from sklearn.impute import KNNImputer
from sklearn.preprocessing import OneHotEncoder,StandardScaler,LabelEncoder

data=pd.read_csv('train2.csv')
data.head()

data.drop(['location'], axis=1)

missing_data= data.isnull().sum(axis=0).reset_index()
missing_data

# As the number of followers can be zero, etc so we no need to change the null values

data = data[data.Type != "South Dakota"]

data.plot(kind="scatter",
           x="following",
           y="Type",
           figsize=(5,5),
           color="black");

data.plot(kind="scatter",
           x="following",
           y="Type",
           figsize=(5,5),
           color="black");

data=data.fillna(0)

data.head()

data['v1_nm'] = data.Type.map({'Quality':0, 'Spam':1})
data.head()

X = data[data.columns[0:4]]
y = data['v1_nm']
print(X)
print(y)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y , random_state=1)

from sklearn.preprocessing import StandardScaler

ss_train = StandardScaler()
X_train = ss_train.fit_transform(X_train)

ss_test = StandardScaler()
X_test = ss_test.fit_transform(X_test)

# Training the K-NN model on the Training set
from sklearn.neighbors import KNeighborsClassifier
classifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix, accuracy_score,classification_report
cm = confusion_matrix(y_test, y_pred)
ac = accuracy_score(y_test, y_pred)
print(ac)
print(classification_report(y_test,y_pred))

"""Binary Classification"""

# create the linear model SGDclassifier
from sklearn.linear_model import SGDClassifier
linear_clf = SGDClassifier()

# Train the classifier using fit() function
linear_clf.fit(X_train, y_train)

# Print the learned coeficients
print ("\nThe coefficients of the linear boundary are:", linear_clf.coef_)
print ("\nThe point of intersection of the line are:",linear_clf.intercept_)

# Evaluate the result
from sklearn import metrics
y_train_pred = linear_clf.predict(X_train)
print ("\nThe Accuracy of our classifier is:", metrics.accuracy_score(y_train, y_train_pred)*100)
print(metrics.classification_report(y_train, y_train_pred))

"""Decision Trees"""

# Create Decision Tree classifer object
clf = DecisionTreeClassifier()

# Train Decision Tree Classifer
clf = clf.fit(X_train,y_train)

#Predict the response for test dataset
y_pred = clf.predict(X_test)

print("Accuracy:",metrics.accuracy_score(y_test, y_pred))
print(metrics.classification_report(y_test, y_pred))

from sklearn import tree
 tree.plot_tree(clf)

"""Random Forest"""

from sklearn.ensemble import RandomForestClassifier

spam_classifier = RandomForestClassifier(n_estimators=200, random_state=0)
spam_classifier.fit(X_train, y_train)
# Use the classifier for predictions
predictions = spam_classifier.predict(X_test)

print(metrics.confusion_matrix(y_test, predictions))
print(metrics.accuracy_score(y_test, predictions))
print(metrics.classification_report(y_test, predictions))

df3=pd.read_csv('test.csv')
df3.head()

df3 = df3.drop(["Id","Tweet","location"],axis=1)

df3.isnull().sum()

df3=df3.fillna(0)

# Training the K-NN model on the Training set
from sklearn.neighbors import KNeighborsClassifier
classifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)
classifier.fit(X_train, y_train)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix, accuracy_score,classification_report
cm = confusion_matrix(y_test, y_pred)
ac = accuracy_score(y_test, y_pred)
print(ac)
print(classification_report(y_test,y_pred))

y_pred = classifier.predict(df3)

y_pred

ans = pd.DataFrame()
ans["Id"] = np.arange(0,785)
ans["Type"] = y_pred
print(ans.head())

from pathlib import Path
filepath = Path('statsub.csv')
ans.to_csv(filepath)
# # print(data_test)

"""# Real Time data analysis"""

import tweepy

#Put your Bearer Token in the parenthesis below
client = tweepy.Client(bearer_token='AAAAAAAAAAAAAAAAAAAAAHbJhgEAAAAAb0Wbujbwy1VtUOx9Ytmd4YG5YtA%3DhOfhBfhiqdue61IidFzhFwESIqm8FqswWbHNtwDjwWgXbm3QV7')

# Get tweets that contain the hashtag #petday
# -is:retweet means I don't want retweets
# lang:en is asking for the tweets to be in english
query = '#CSKvsRR  lang:En'
tweets = client.search_recent_tweets(query=query, tweet_fields=['context_annotations', 'created_at'], max_results=100)

l=[]

for tweet in tweets.data:
    print(tweet.text)
    l.append(tweet.text)
    print("\n")

l

df = pd.DataFrame({'tweets':l})

df

df.describe()

# transform testing data (using fitted vocabulary) into a document-term matrix
X_test_real = vect.transform(df['tweets'])
X_test_real

# Commented out IPython magic to ensure Python compatibility.
from sklearn.naive_bayes import MultinomialNB
nb = MultinomialNB()

# %time nb.fit(X_train_dtm, y_train)

y_pred_class = nb.predict(X_test_real)
print(y_pred_class)

"""# Kaggle accuracy

![Screenshot 2023-04-13 190346.png](data:image/png;base64,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)
"""